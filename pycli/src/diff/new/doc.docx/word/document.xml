<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<w:document xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:v="urn:schemas-microsoft-com:vml" xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main" xmlns:w10="urn:schemas-microsoft-com:office:word" xmlns:wp="http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing" xmlns:wps="http://schemas.microsoft.com/office/word/2010/wordprocessingShape" xmlns:wpg="http://schemas.microsoft.com/office/word/2010/wordprocessingGroup" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" xmlns:wp14="http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing" xmlns:w14="http://schemas.microsoft.com/office/word/2010/wordml" mc:Ignorable="w14 wp14"><w:body><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b/><w:bCs/></w:rPr><w:t>M29704b3a-f0fb-256a-856b-38b9795f403fM29704b3a-f0fb-256a-856b-38b9795f403findexmodules |next |previous | Python »   Documentation » The Python Standard Library » 17.</w:t></w:r><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t xml:space="preserve"> Interprocess Communication and Networking »</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>17.2. socket — Low-level networking interface</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>This module provides access to the BSD socket interface. It is available on all modern Unix systems, Windows, Mac OS X, BeOS, OS/2, and probably additional platforms.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Note Some behavior may be platform dependent, since calls are made to the operating system socket APIs.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>For an introduction to socket programming (in C), see the following papers: An Introductory 4.3BSD Interprocess Communication Tutorial, by Stuart Sechrest and An Advanced 4.3BSD Interprocess Communication Tutorial, by Samuel J. Leffler et al, both in the UNIX Programmer’s Manual, Supplementary Documents 1 (sections PS1:7 and PS1:8). The platform-specific reference material for the various socket-related system calls are also a valuable source of information on the details of socket semantics. For Unix, refer to the manual pages; for Windows, see the WinSock (or Winsock 2) specification. For IPv6-ready APIs, readers may want to refer to RFC 3493 titled Basic Socket Interface Extensions for IPv6.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>The Python interface is a straightforward transliteration of the Unix system call and library interface for sockets to Python’s object-oriented style: the socket() function returns a socket object whose methods implement the various socket system calls. Parameter types are somewhat higher-level than in the C interface: as with read() and write() operations on Python files, buffer allocation on receive operations is automatic, and buffer length is implicit on send operations.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Socket addresses are represented as follows: A single string is used for the AF_UNIX address family. A pair (host, port) is used for the AF_INET address family, where host is a string representing either a hostname in Internet domain notation like &apos;daring.cwi.nl&apos; or an IPv4 address like &apos;100.50.200.5&apos;, and port is an integer. For AF_INET6 address family, a four-tuple (host, port, flowinfo, scopeid) is used, where flowinfo and scopeid represents sin6_flowinfo and sin6_scope_id member in struct sockaddr_in6 in C. For socket module methods, flowinfo and scopeid can be omitted just for backward compatibility. Note, however, omission of scopeid can cause problems in manipulating scoped IPv6 addresses. Other address families are currently not supported. The address format required by a particular socket object is automatically selected based on the address family specified when the socket object was created.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>For IPv4 addresses, two special forms are accepted instead of a host address: the empty string represents INADDR_ANY, and the string &apos;&lt;broadcast&gt;&apos; represents INADDR_BROADCAST. The behavior is not available for IPv6 for backward compatibility, therefore, you may want to avoid these if you intend to support IPv6 with your Python programs.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>If you use a hostname in the host portion of IPv4/v6 socket address, the program may show a nondeterministic behavior, as Python uses the first address returned from the DNS resolution. The socket address will be resolved differently into an actual IPv4/v6 address, depending on the results from DNS resolution and/or the host configuration. For deterministic behavior use a numeric address in host portion.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>New in version 2.5: AF_NETLINK sockets are represented as pairs pid, groups.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>New in version 2.6: Linux-only support for TIPC is also available using the AF_TIPC address family. TIPC is an open, non-IP based networked protocol designed for use in clustered computer environments. Addresses are represented by a tuple, and the fields depend on the address type. The general tuple form is (addr_type, v1, v2, v3 [, scope]), where:</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>addr_type is one of TIPC_ADDR_NAMESEQ, TIPC_ADDR_NAME, or TIPC_ADDR_ID.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>scope is one of TIPC_ZONE_SCOPE, TIPC_CLUSTER_SCOPE, and TIPC_NODE_SCOPE.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>If addr_type is TIPC_ADDR_NAME, then v1 is the server type, v2 is the port identifier, and v3 should be 0.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>If addr_type is TIPC_ADDR_NAMESEQ, then v1 is the server type, v2 is the lower port number, and v3 is the upper port number.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>If addr_type is TIPC_ADDR_ID, then v1 is the node, v2 is the reference, and v3 should be set to 0.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>All errors raise exceptions. The normal exceptions for invalid argument types and out-of-memory conditions can be raised; errors related to socket or address semantics raise the error socket.error.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Non-blocking mode is supported through setblocking(). A generalization of this based on timeouts is supported through settimeout().</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>The module socket exports the following constants and functions:</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>exception socket.error</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>This exception is raised for socket-related errors. The accompanying value is either a string telling what went wrong or a pair (errno, string) representing an error returned by a system call, similar to the value accompanying os.error. See the module errno, which contains names for the error codes defined by the underlying operating system.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Changed in version 2.6: socket.error is now a child class of IOError.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>exception socket.herror</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>This exception is raised for address-related errors, i.e. for functions that use h_errno in the C API, including gethostbyname_ex() and gethostbyaddr().</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>The accompanying value is a pair (h_errno, string) representing an error returned by a library call. string represents the description of h_errno, as returned by the hstrerror() C function.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>exception socket.gaierror</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>This exception is raised for address-related errors, for getaddrinfo() and getnameinfo(). The accompanying value is a pair (error, string) representing an error returned by a library call. string represents the description of error, as returned by the gai_strerror() C function. The error value will match one of the EAI_* constants defined in this module.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>exception socket.timeout</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>This exception is raised when a timeout occurs on a socket which has had timeouts enabled via a prior call to settimeout(). The accompanying value is a string whose value is currently always “timed out”.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>New in version 2.3.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.AF_UNIX</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.AF_INET</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.AF_INET6</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>These constants represent the address (and protocol) families, used for the first argument to socket(). If the AF_UNIX constant is not defined then this protocol is unsupported.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.SOCK_STREAM</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.SOCK_DGRAM</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.SOCK_RAW</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.SOCK_RDM</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.SOCK_SEQPACKET</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>These constants represent the socket types, used for the second argument to socket(). (Only SOCK_STREAM and SOCK_DGRAM appear to be generally useful.)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>SO_*</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.SOMAXCONN</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>MSG_*</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>SOL_*</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>IPPROTO_*</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>IPPORT_*</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>INADDR_*</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>IP_*</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>IPV6_*</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>EAI_*</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>AI_*</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>NI_*</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>TCP_*</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Many constants of these forms, documented in the Unix documentation on sockets and/or the IP protocol, are also defined in the socket module. They are generally used in arguments to the setsockopt() and getsockopt() methods of socket objects. In most cases, only those symbols that are defined in the Unix header files are defined; for a few symbols, default values are provided.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>SIO_*</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>RCVALL_*</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Constants for Windows’ WSAIoctl(). The constants are used as arguments to the ioctl() method of socket objects.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>New in version 2.6.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>TIPC_*</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>TIPC related constants, matching the ones exported by the C socket API. See the TIPC documentation for more information.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>New in version 2.6.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.has_ipv6</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>This constant contains a boolean value which indicates if IPv6 is supported on this platform.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>New in version 2.3.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.create_connection(address[, timeout[, source_address]])</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Connect to a TCP service listening on the Internet address (a 2-tuple (host, port)), and return the socket object. This is a higher-level function than socket.connect(): if host is a non-numeric hostname, it will try to resolve it for both AF_INET and AF_INET6, and then try to connect to all possible addresses in turn until a connection succeeds. This makes it easy to write clients that are compatible to both IPv4 and IPv6.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Passing the optional timeout parameter will set the timeout on the socket instance before attempting to connect. If no timeout is supplied, the global default timeout setting returned by getdefaulttimeout() is used.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>If supplied, source_address must be a 2-tuple (host, port) for the socket to bind to as its source address before connecting. If host or port are ‘’ or 0 respectively the OS default behavior will be used.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>New in version 2.6.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Changed in version 2.7: source_address was added.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.getaddrinfo(host, port[, family[, socktype[, proto[, flags]]]])</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Translate the host/port argument into a sequence of 5-tuples that contain all the necessary arguments for creating a socket connected to that service. host is a domain name, a string representation of an IPv4/v6 address or None. port is a string service name such as &apos;http&apos;, a numeric port number or None. By passing None as the value of host and port, you can pass NULL to the underlying C API.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>The family, socktype and proto arguments can be optionally specified in order to narrow the list of addresses returned. By default, their value is 0, meaning that the full range of results is selected. The flags argument can be one or several of the AI_* constants, and will influence how results are computed and returned. Its default value is 0. For example, AI_NUMERICHOST will disable domain name resolution and will raise an error if host is a domain name.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>The function returns a list of 5-tuples with the following structure:</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>(family, socktype, proto, canonname, sockaddr)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>In these tuples, family, socktype, proto are all integers and are meant to be passed to the socket() function. canonname will be a string representing the canonical name of the host if AI_CANONNAME is part of the flags argument; else canonname will be empty. sockaddr is a tuple describing a socket address, whose format depends on the returned family (a (address, port) 2-tuple for AF_INET, a (address, port, flow info, scope id) 4-tuple for AF_INET6), and is meant to be passed to the socket.connect() method.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>The following example fetches address information for a hypothetical TCP connection to example.org on port 80 (results may differ on your system if IPv6 isn’t enabled):</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>&gt;&gt;&gt;</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>&gt;&gt;&gt; socket.getaddrinfo(&quot;example.org&quot;, 80, 0, 0, socket.IPPROTO_TCP)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>[(10, 1, 6, &apos;&apos;, (&apos;2606:2800:220:1:248:1893:25c8:1946&apos;, 80, 0, 0)),</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t xml:space="preserve"> </w:t></w:r><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>(2, 1, 6, &apos;&apos;, (&apos;93.184.216.34&apos;, 80))]</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>New in version 2.2.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.getfqdn([name])</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Return a fully qualified domain name for name. If name is omitted or empty, it is interpreted as the local host. To find the fully qualified name, the hostname returned by gethostbyaddr() is checked, followed by aliases for the host, if available. The first name which includes a period is selected. In case no fully qualified domain name is available, the hostname as returned by gethostname() is returned.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>New in version 2.0.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.gethostbyname(hostname)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Translate a host name to IPv4 address format. The IPv4 address is returned as a string, such as &apos;100.50.200.5&apos;. If the host name is an IPv4 address itself it is returned unchanged. See gethostbyname_ex() for a more complete interface. gethostbyname() does not support IPv6 name resolution, and getaddrinfo() should be used instead for IPv4/v6 dual stack support.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.gethostbyname_ex(hostname)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Translate a host name to IPv4 address format, extended interface. Return a triple (hostname, aliaslist, ipaddrlist) where hostname is the primary host name responding to the given ip_address, aliaslist is a (possibly empty) list of alternative host names for the same address, and ipaddrlist is a list of IPv4 addresses for the same interface on the same host (often but not always a single address). gethostbyname_ex() does not support IPv6 name resolution, and getaddrinfo() should be used instead for IPv4/v6 dual stack support.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.gethostname()</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Return a string containing the hostname of the machine where the Python interpreter is currently executing.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>If you want to know the current machine’s IP address, you may want to use gethostbyname(gethostname()). This operation assumes that there is a valid address-to-host mapping for the host, and the assumption does not always hold.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Note: gethostname() doesn’t always return the fully qualified domain name; use getfqdn() (see above).</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.gethostbyaddr(ip_address)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Return a triple (hostname, aliaslist, ipaddrlist) where hostname is the primary host name responding to the given ip_address, aliaslist is a (possibly empty) list of alternative host names for the same address, and ipaddrlist is a list of IPv4/v6 addresses for the same interface on the same host (most likely containing only a single address). To find the fully qualified domain name, use the function getfqdn(). gethostbyaddr() supports both IPv4 and IPv6.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.getnameinfo(sockaddr, flags)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Translate a socket address sockaddr into a 2-tuple (host, port). Depending on the settings of flags, the result can contain a fully-qualified domain name or numeric address representation in host. Similarly, port can contain a string port name or a numeric port number.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>New in version 2.2.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.getprotobyname(protocolname)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Translate an Internet protocol name (for example, &apos;icmp&apos;) to a constant suitable for passing as the (optional) third argument to the socket() function. This is usually only needed for sockets opened in “raw” mode (SOCK_RAW); for the normal socket modes, the correct protocol is chosen automatically if the protocol is omitted or zero.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.getservbyname(servicename[, protocolname])</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Translate an Internet service name and protocol name to a port number for that service. The optional protocol name, if given, should be &apos;tcp&apos; or &apos;udp&apos;, otherwise any protocol will match.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.getservbyport(port[, protocolname])</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Translate an Internet port number and protocol name to a service name for that service. The optional protocol name, if given, should be &apos;tcp&apos; or &apos;udp&apos;, otherwise any protocol will match.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.socket([family[, type[, proto]]])</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Create a new socket using the given address family, socket type and protocol number. The address family should be AF_INET (the default), AF_INET6 or AF_UNIX. The socket type should be SOCK_STREAM (the default), SOCK_DGRAM or perhaps one of the other SOCK_ constants. The protocol number is usually zero and may be omitted in that case.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.socketpair([family[, type[, proto]]])</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Build a pair of connected socket objects using the given address family, socket type, and protocol number. Address family, socket type, and protocol number are as for the socket() function above. The default family is AF_UNIX if defined on the platform; otherwise, the default is AF_INET. Availability: Unix.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>New in version 2.4.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.fromfd(fd, family, type[, proto])</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Duplicate the file descriptor fd (an integer as returned by a file object’s fileno() method) and build a socket object from the result. Address family, socket type and protocol number are as for the socket() function above. The file descriptor should refer to a socket, but this is not checked — subsequent operations on the object may fail if the file descriptor is invalid. This function is rarely needed, but can be used to get or set socket options on a socket passed to a program as standard input or output (such as a server started by the Unix inet daemon). The socket is assumed to be in blocking mode. Availability: Unix.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.ntohl(x)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Convert 32-bit positive integers from network to host byte order. On machines where the host byte order is the same as network byte order, this is a no-op; otherwise, it performs a 4-byte swap operation.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.ntohs(x)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Convert 16-bit positive integers from network to host byte order. On machines where the host byte order is the same as network byte order, this is a no-op; otherwise, it performs a 2-byte swap operation.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.htonl(x)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Convert 32-bit positive integers from host to network byte order. On machines where the host byte order is the same as network byte order, this is a no-op; otherwise, it performs a 4-byte swap operation.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.htons(x)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Convert 16-bit positive integers from host to network byte order. On machines where the host byte order is the same as network byte order, this is a no-op; otherwise, it performs a 2-byte swap operation.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.inet_aton(ip_string)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Convert an IPv4 address from dotted-quad string format (for example, ‘123.45.67.89’) to 32-bit packed binary format, as a string four characters in length. This is useful when conversing with a program that uses the standard C library and needs objects of type struct in_addr, which is the C type for the 32-bit packed binary this function returns.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>inet_aton() also accepts strings with less than three dots; see the Unix manual page inet(3) for details.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>If the IPv4 address string passed to this function is invalid, socket.error will be raised. Note that exactly what is valid depends on the underlying C implementation of inet_aton().</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>inet_aton() does not support IPv6, and inet_pton() should be used instead for IPv4/v6 dual stack support.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.inet_ntoa(packed_ip)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Convert a 32-bit packed IPv4 address (a string four characters in length) to its standard dotted-quad string representation (for example, ‘123.45.67.89’). This is useful when conversing with a program that uses the standard C library and needs objects of type struct in_addr, which is the C type for the 32-bit packed binary data this function takes as an argument.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>If the string passed to this function is not exactly 4 bytes in length, socket.error will be raised. inet_ntoa() does not support IPv6, and inet_ntop() should be used instead for IPv4/v6 dual stack support.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.inet_pton(address_family, ip_string)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Convert an IP address from its family-specific string format to a packed, binary format. inet_pton() is useful when a library or network protocol calls for an object of type struct in_addr (similar to inet_aton()) or struct in6_addr.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Supported values for address_family are currently AF_INET and AF_INET6. If the IP address string ip_string is invalid, socket.error will be raised. Note that exactly what is valid depends on both the value of address_family and the underlying implementation of inet_pton().</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Availability: Unix (maybe not all platforms).</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>New in version 2.3.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.inet_ntop(address_family, packed_ip)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Convert a packed IP address (a string of some number of characters) to its standard, family-specific string representation (for example, &apos;7.10.0.5&apos; or &apos;5aef:2b::8&apos;) inet_ntop() is useful when a library or network protocol returns an object of type struct in_addr (similar to inet_ntoa()) or struct in6_addr.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Supported values for address_family are currently AF_INET and AF_INET6. If the string packed_ip is not the correct length for the specified address family, ValueError will be raised. A socket.error is raised for errors from the call to inet_ntop().</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Availability: Unix (maybe not all platforms).</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>New in version 2.3.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.getdefaulttimeout()</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Return the default timeout in seconds (float) for new socket objects. A value of None indicates that new socket objects have no timeout. When the socket module is first imported, the default is None.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>New in version 2.3.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.setdefaulttimeout(timeout)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Set the default timeout in seconds (float) for new socket objects. A value of None indicates that new socket objects have no timeout. When the socket module is first imported, the default is None.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>New in version 2.3.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.SocketType</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>This is a Python type object that represents the socket object type. It is the same as type(socket(...)).</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>See also</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Module SocketServer</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Classes that simplify writing network servers.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Module ssl</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>A TLS/SSL wrapper for socket objects.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>17.2.1. Socket Objects</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Socket objects have the following methods. Except for makefile() these correspond to Unix system calls applicable to sockets.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.accept()</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Accept a connection. The socket must be bound to an address and listening for connections. The return value is a pair (conn, address) where conn is a new socket object usable to send and receive data on the connection, and address is the address bound to the socket on the other end of the connection.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.bind(address)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Bind the socket to address. The socket must not already be bound. (The format of address depends on the address family — see above.)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Note This method has historically accepted a pair of parameters for AF_INET addresses instead of only a tuple. This was never intentional and is no longer available in Python 2.0 and later.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.close()</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Close the socket. All future operations on the socket object will fail. The remote end will receive no more data (after queued data is flushed). Sockets are automatically closed when they are garbage-collected.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Note close() releases the resource associated with a connection but does not necessarily close the connection immediately. If you want to close the connection in a timely fashion, call shutdown() before close().</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.connect(address)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Connect to a remote socket at address. (The format of address depends on the address family — see above.)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Note This method has historically accepted a pair of parameters for AF_INET addresses instead of only a tuple. This was never intentional and is no longer available in Python 2.0 and later.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.connect_ex(address)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Like connect(address), but return an error indicator instead of raising an exception for errors returned by the C-level connect() call (other problems, such as “host not found,” can still raise exceptions). The error indicator is 0 if the operation succeeded, otherwise the value of the errno variable. This is useful to support, for example, asynchronous connects.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Note This method has historically accepted a pair of parameters for AF_INET addresses instead of only a tuple. This was never intentional and is no longer available in Python 2.0 and later.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.fileno()</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Return the socket’s file descriptor (a small integer). This is useful with select.select().</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Under Windows the small integer returned by this method cannot be used where a file descriptor can be used (such as os.fdopen()). Unix does not have this limitation.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.getpeername()</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Return the remote address to which the socket is connected. This is useful to find out the port number of a remote IPv4/v6 socket, for instance. (The format of the address returned depends on the address family — see above.) On some systems this function is not supported.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.getsockname()</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Return the socket’s own address. This is useful to find out the port number of an IPv4/v6 socket, for instance. (The format of the address returned depends on the address family — see above.)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.getsockopt(level, optname[, buflen])</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Return the value of the given socket option (see the Unix man page getsockopt(2)). The needed symbolic constants (SO_* etc.) are defined in this module. If buflen is absent, an integer option is assumed and its integer value is returned by the function. If buflen is present, it specifies the maximum length of the buffer used to receive the option in, and this buffer is returned as a string. It is up to the caller to decode the contents of the buffer (see the optional built-in module struct for a way to decode C structures encoded as strings).</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.ioctl(control, option)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Platform:</w:t><w:tab/><w:t>Windows</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>The ioctl() method is a limited interface to the WSAIoctl system interface. Please refer to the Win32 documentation for more information.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>On other platforms, the generic fcntl.fcntl() and fcntl.ioctl() functions may be used; they accept a socket object as their first argument.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>New in version 2.6.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.listen(backlog)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Listen for connections made to the socket. The backlog argument specifies the maximum number of queued connections and should be at least 0; the maximum value is system-dependent (usually 5), the minimum value is forced to 0.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.makefile([mode[, bufsize]])</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Return a file object associated with the socket. (File objects are described in File Objects.) The file object does not close the socket explicitly when its close() method is called, but only removes its reference to the socket object, so that the socket will be closed if it is not referenced from anywhere else.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>The socket must be in blocking mode (it can not have a timeout). The optional mode and bufsize arguments are interpreted the same way as by the built-in file() function.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Note On Windows, the file-like object created by makefile() cannot be used where a file object with a file descriptor is expected, such as the stream arguments of subprocess.Popen().</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.recv(bufsize[, flags])</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Receive data from the socket. The return value is a string representing the data received. The maximum amount of data to be received at once is specified by bufsize. See the Unix manual page recv(2) for the meaning of the optional argument flags; it defaults to zero.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Note For best match with hardware and network realities, the value of bufsize should be a relatively small power of 2, for example, 4096.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.recvfrom(bufsize[, flags])</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Receive data from the socket. The return value is a pair (string, address) where string is a string representing the data received and address is the address of the socket sending the data. See the Unix manual page recv(2) for the meaning of the optional argument flags; it defaults to zero. (The format of address depends on the address family — see above.)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.recvfrom_into(buffer[, nbytes[, flags]])</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Receive data from the socket, writing it into buffer instead of creating a new string. The return value is a pair (nbytes, address) where nbytes is the number of bytes received and address is the address of the socket sending the data. See the Unix manual page recv(2) for the meaning of the optional argument flags; it defaults to zero. (The format of address depends on the address family — see above.)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>New in version 2.5.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.recv_into(buffer[, nbytes[, flags]])</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Receive up to nbytes bytes from the socket, storing the data into a buffer rather than creating a new string. If nbytes is not specified (or 0), receive up to the size available in the given buffer. Returns the number of bytes received. See the Unix manual page recv(2) for the meaning of the optional argument flags; it defaults to zero.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>New in version 2.5.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.send(string[, flags])</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Send data to the socket. The socket must be connected to a remote socket. The optional flags argument has the same meaning as for recv() above. Returns the number of bytes sent. Applications are responsible for checking that all data has been sent; if only some of the data was transmitted, the application needs to attempt delivery of the remaining data. For further information on this concept, consult the Socket Programming HOWTO.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.sendall(string[, flags])</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Send data to the socket. The socket must be connected to a remote socket. The optional flags argument has the same meaning as for recv() above. Unlike send(), this method continues to send data from string until either all data has been sent or an error occurs. None is returned on success. On error, an exception is raised, and there is no way to determine how much data, if any, was successfully sent.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.sendto(string, address)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.sendto(string, flags, address)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Send data to the socket. The socket should not be connected to a remote socket, since the destination socket is specified by address. The optional flags argument has the same meaning as for recv() above. Return the number of bytes sent. (The format of address depends on the address family — see above.)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.setblocking(flag)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Set blocking or non-blocking mode of the socket: if flag is 0, the socket is set to non-blocking, else to blocking mode. Initially all sockets are in blocking mode. In non-blocking mode, if a recv() call doesn’t find any data, or if a send() call can’t immediately dispose of the data, an error exception is raised; in blocking mode, the calls block until they can proceed. s.setblocking(0) is equivalent to s.settimeout(0.0); s.setblocking(1) is equivalent to s.settimeout(None).</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.settimeout(value)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Set a timeout on blocking socket operations. The value argument can be a nonnegative float expressing seconds, or None. If a float is given, subsequent socket operations will raise a timeout exception if the timeout period value has elapsed before the operation has completed. Setting a timeout of None disables timeouts on socket operations. s.settimeout(0.0) is equivalent to s.setblocking(0); s.settimeout(None) is equivalent to s.setblocking(1).</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>New in version 2.3.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.gettimeout()</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Return the timeout in seconds (float) associated with socket operations, or None if no timeout is set. This reflects the last call to setblocking() or settimeout().</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>New in version 2.3.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Some notes on socket blocking and timeouts: A socket object can be in one of three modes: blocking, non-blocking, or timeout. Sockets are always created in blocking mode. In blocking mode, operations block until complete or the system returns an error (such as connection timed out). In non-blocking mode, operations fail (with an error that is unfortunately system-dependent) if they cannot be completed immediately. In timeout mode, operations fail if they cannot be completed within the timeout specified for the socket or if the system returns an error. The setblocking() method is simply a shorthand for certain settimeout() calls.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Timeout mode internally sets the socket in non-blocking mode. The blocking and timeout modes are shared between file descriptors and socket objects that refer to the same network endpoint. A consequence of this is that file objects returned by the makefile() method must only be used when the socket is in blocking mode; in timeout or non-blocking mode file operations that cannot be completed immediately will fail.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Note that the connect() operation is subject to the timeout setting, and in general it is recommended to call settimeout() before calling connect() or pass a timeout parameter to create_connection(). The system network stack may return a connection timeout error of its own regardless of any Python socket timeout setting.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.setsockopt(level, optname, value)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Set the value of the given socket option (see the Unix manual page setsockopt(2)). The needed symbolic constants are defined in the socket module (SO_* etc.). The value can be an integer or a string representing a buffer. In the latter case it is up to the caller to ensure that the string contains the proper bits (see the optional built-in module struct for a way to encode C structures as strings).</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.shutdown(how)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Shut down one or both halves of the connection. If how is SHUT_RD, further receives are disallowed. If how is SHUT_WR, further sends are disallowed. If how is SHUT_RDWR, further sends and receives are disallowed. Depending on the platform, shutting down one half of the connection can also close the opposite half (e.g. on Mac OS X, shutdown(SHUT_WR) does not allow further reads on the other end of the connection).</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Note that there are no methods read() or write(); use recv() and send() without flags argument instead.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Socket objects also have these (read-only) attributes that correspond to the values given to the socket constructor.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.family</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>The socket family.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>New in version 2.5.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.type</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>The socket type.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>New in version 2.5.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.proto</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>The socket protocol.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>New in version 2.5.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>17.2.2. Example</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Here are four minimal example programs using the TCP/IP protocol: a server that echoes all data that it receives back (servicing only one client), and a client using it. Note that a server must perform the sequence socket(), bind(), listen(), accept() (possibly repeating the accept() to service more than one client), while a client only needs the sequence socket(), connect(). Also note that the server does not sendall()/recv() on the socket it is listening on but on the new socket returned by accept().</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>The first two examples support IPv4 only.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t># Echo server program</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>import socket</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>HOST = &apos;&apos;                 # Symbolic name meaning all available interfaces</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>PORT = 50007              # Arbitrary non-privileged port</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>s.bind((HOST, PORT))</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>s.listen(1)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>conn, addr = s.accept()</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>print &apos;Connected by&apos;, addr</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>while 1:</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t xml:space="preserve">    </w:t></w:r><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>data = conn.recv(1024)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t xml:space="preserve">    </w:t></w:r><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>if not data: break</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t xml:space="preserve">    </w:t></w:r><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>conn.sendall(data)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>conn.close()</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t># Echo client program</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>import socket</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>HOST = &apos;daring.cwi.nl&apos;    # The remote host</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>PORT = 50007              # The same port as used by the server</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>s.connect((HOST, PORT))</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>s.sendall(&apos;Hello, world&apos;)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>data = s.recv(1024)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>s.close()</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>print &apos;Received&apos;, repr(data)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>The next two examples are identical to the above two, but support both IPv4 and IPv6. The server side will listen to the first address family available (it should listen to both instead). On most of IPv6-ready systems, IPv6 will take precedence and the server may not accept IPv4 traffic. The client side will try to connect to the all addresses returned as a result of the name resolution, and sends traffic to the first one connected successfully.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t># Echo server program</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>import socket</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>import sys</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>HOST = None               # Symbolic name meaning all available interfaces</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>PORT = 50007              # Arbitrary non-privileged port</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>s = None</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>for res in socket.getaddrinfo(HOST, PORT, socket.AF_UNSPEC,</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t xml:space="preserve">                              </w:t></w:r><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.SOCK_STREAM, 0, socket.AI_PASSIVE):</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t xml:space="preserve">    </w:t></w:r><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>af, socktype, proto, canonname, sa = res</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t xml:space="preserve">    </w:t></w:r><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>try:</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t xml:space="preserve">        </w:t></w:r><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>s = socket.socket(af, socktype, proto)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t xml:space="preserve">    </w:t></w:r><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>except socket.error as msg:</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t xml:space="preserve">        </w:t></w:r><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>s = None</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t xml:space="preserve">        </w:t></w:r><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>continue</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t xml:space="preserve">    </w:t></w:r><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>try:</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t xml:space="preserve">        </w:t></w:r><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>s.bind(sa)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t xml:space="preserve">        </w:t></w:r><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>s.listen(1)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t xml:space="preserve">    </w:t></w:r><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>except socket.error as msg:</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t xml:space="preserve">        </w:t></w:r><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>s.close()</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t xml:space="preserve">        </w:t></w:r><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>s = None</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t xml:space="preserve">        </w:t></w:r><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>continue</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t xml:space="preserve">    </w:t></w:r><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>break</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>if s is None:</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t xml:space="preserve">    </w:t></w:r><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>print &apos;could not open socket&apos;</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t xml:space="preserve">    </w:t></w:r><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>sys.exit(1)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>conn, addr = s.accept()</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>print &apos;Connected by&apos;, addr</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>while 1:</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t xml:space="preserve">    </w:t></w:r><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>data = conn.recv(1024)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t xml:space="preserve">    </w:t></w:r><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>if not data: break</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t xml:space="preserve">    </w:t></w:r><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>conn.send(data)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>conn.close()</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t># Echo client program</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>import socket</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>import sys</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>HOST = &apos;daring.cwi.nl&apos;    # The remote host</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>PORT = 50007              # The same port as used by the server</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>s = None</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>for res in socket.getaddrinfo(HOST, PORT, socket.AF_UNSPEC, socket.SOCK_STREAM):</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t xml:space="preserve">    </w:t></w:r><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>af, socktype, proto, canonname, sa = res</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t xml:space="preserve">    </w:t></w:r><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>try:</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t xml:space="preserve">        </w:t></w:r><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>s = socket.socket(af, socktype, proto)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t xml:space="preserve">    </w:t></w:r><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>except socket.error as msg:</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t xml:space="preserve">        </w:t></w:r><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>s = None</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t xml:space="preserve">        </w:t></w:r><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>continue</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t xml:space="preserve">    </w:t></w:r><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>try:</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t xml:space="preserve">        </w:t></w:r><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>s.connect(sa)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t xml:space="preserve">    </w:t></w:r><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>except socket.error as msg:</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t xml:space="preserve">        </w:t></w:r><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>s.close()</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t xml:space="preserve">        </w:t></w:r><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>s = None</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t xml:space="preserve">        </w:t></w:r><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>continue</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t xml:space="preserve">    </w:t></w:r><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>break</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>if s is None:</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t xml:space="preserve">    </w:t></w:r><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>print &apos;could not open socket&apos;</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t xml:space="preserve">    </w:t></w:r><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>sys.exit(1)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>s.sendall(&apos;Hello, world&apos;)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>data = s.recv(1024)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>s.close()</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>print &apos;Received&apos;, repr(data)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>The last example shows how to write a very simple network sniffer with raw sockets on Windows. The example requires administrator privileges to modify the interface:</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>import socket</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t># the public network interface</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>HOST = socket.gethostbyname(socket.gethostname())</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t># create a raw socket and bind it to the public interface</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_IP)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>s.bind((HOST, 0))</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t># Include IP headers</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>s.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t># receive all packages</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>s.ioctl(socket.SIO_RCVALL, socket.RCVALL_ON)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t># receive a package</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>print s.recvfrom(65565)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t># disabled promiscuous mode</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>s.ioctl(socket.SIO_RCVALL, socket.RCVALL_OFF)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Running an example several times with too small delay between executions, could lead to this error:</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.error: [Errno 98] Address already in use</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>This is because the previous execution has left the socket in a TIME_WAIT state, and can’t be immediately reused.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>There is a socket flag to set, in order to prevent this, socket.SO_REUSEADDR:</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>s.bind((HOST, PORT))</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>the SO_REUSEADDR flag tells the kernel to reuse a local socket in TIME_WAIT state, without waiting for its natural timeout to expire.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Table Of Contents</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>17.2. socket — Low-level networking interface</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>17.2.1. Socket Objects</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>17.2.2. Example</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Previous topic</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>17.1. subprocess — Subprocess management</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Next topic</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>17.3. ssl — TLS/SSL wrapper for socket objects</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>This Page</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Report a Bug</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Show Source</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Quick search</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t xml:space="preserve"> </w:t></w:r><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Go</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Enter search terms or a module, class or function name.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>«</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>indexmodules |next |previous | Python »   Documentation » The Python Standard Library » 17. Interprocess Communication and Networking »</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t xml:space="preserve">© Copyright 1990-2017, Python Software Foundation. </w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t xml:space="preserve">The Python Software Foundation is a non-profit corporation. Please donate. </w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t xml:space="preserve">Last updated on Mar 27, 2017. Found a bug? </w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Created using Sphinx 1.3.3.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>M29704b3a-f0fb-256a-856b-38b9795f403fM29704b3a-f0fb-256a-856b-38b9795f403findexmodules |next |previous | Python »   Documentation » The Python Standard Library » 17. Interprocess Communication and Networking »</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>17.2. socket — Low-level networking interface</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>This module provides access to the BSD socket interface. It is available on all modern Unix systems, Windows, Mac OS X, BeOS, OS/2, and probably additional platforms.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Note Some behavior may be platform dependent, since calls are made to the operating system socket APIs.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>For an introduction to socket programming (in C), see the following papers: An Introductory 4.3BSD Interprocess Communication Tutorial, by Stuart Sechrest and An Advanced 4.3BSD Interprocess Communication Tutorial, by Samuel J. Leffler et al, both in the UNIX Programmer’s Manual, Supplementary Documents 1 (sections PS1:7 and PS1:8). The platform-specific reference material for the various socket-related system calls are also a valuable source of information on the details of socket semantics. For Unix, refer to the manual pages; for Windows, see the WinSock (or Winsock 2) specification. For IPv6-ready APIs, readers may want to refer to RFC 3493 titled Basic Socket Interface Extensions for IPv6.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>The Python interface is a straightforward transliteration of the Unix system call and library interface for sockets to Python’s object-oriented style: the socket() function returns a socket object whose methods implement the various socket system calls. Parameter types are somewhat higher-level than in the C interface: as with read() and write() operations on Python files, buffer allocation on receive operations is automatic, and buffer length is implicit on send operations.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Socket addresses are represented as follows: A single string is used for the AF_UNIX address family. A pair (host, port) is used for the AF_INET address family, where host is a string representing either a hostname in Internet domain notation like &apos;daring.cwi.nl&apos; or an IPv4 address like &apos;100.50.200.5&apos;, and port is an integer. For AF_INET6 address family, a four-tuple (host, port, flowinfo, scopeid) is used, where flowinfo and scopeid represents sin6_flowinfo and sin6_scope_id member in struct sockaddr_in6 in C. For socket module methods, flowinfo and scopeid can be omitted just for backward compatibility. Note, however, omission of scopeid can cause problems in manipulating scoped IPv6 addresses. Other address families are currently not supported. The address format required by a particular socket object is automatically selected based on the address family specified when the socket object was created.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>For IPv4 addresses, two special forms are accepted instead of a host address: the empty string represents INADDR_ANY, and the string &apos;&lt;broadcast&gt;&apos; represents INADDR_BROADCAST. The behavior is not available for IPv6 for backward compatibility, therefore, you may want to avoid these if you intend to support IPv6 with your Python programs.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>If you use a hostname in the host portion of IPv4/v6 socket address, the program may show a nondeterministic behavior, as Python uses the first address returned from the DNS resolution. The socket address will be resolved differently into an actual IPv4/v6 address, depending on the results from DNS resolution and/or the host configuration. For deterministic behavior use a numeric address in host portion.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>New in version 2.5: AF_NETLINK sockets are represented as pairs pid, groups.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>New in version 2.6: Linux-only support for TIPC is also available using the AF_TIPC address family. TIPC is an open, non-IP based networked protocol designed for use in clustered computer environments. Addresses are represented by a tuple, and the fields depend on the address type. The general tuple form is (addr_type, v1, v2, v3 [, scope]), where:</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>addr_type is one of TIPC_ADDR_NAMESEQ, TIPC_ADDR_NAME, or TIPC_ADDR_ID.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>scope is one of TIPC_ZONE_SCOPE, TIPC_CLUSTER_SCOPE, and TIPC_NODE_SCOPE.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>If addr_type is TIPC_ADDR_NAME, then v1 is the server type, v2 is the port identifier, and v3 should be 0.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>If addr_type is TIPC_ADDR_NAMESEQ, then v1 is the server type, v2 is the lower port number, and v3 is the upper port number.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>If addr_type is TIPC_ADDR_ID, then v1 is the node, v2 is the reference, and v3 should be set to 0.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>All errors raise exceptions. The normal exceptions for invalid argument types and out-of-memory conditions can be raised; errors related to socket or address semantics raise the error socket.error.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Non-blocking mode is supported through setblocking(). A generalization of this based on timeouts is supported through settimeout().</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>The module socket exports the following constants and functions:</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>exception socket.error</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>This exception is raised for socket-related errors. The accompanying value is either a string telling what went wrong or a pair (errno, string) representing an error returned by a system call, similar to the value accompanying os.error. See the module errno, which contains names for the error codes defined by the underlying operating system.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Changed in version 2.6: socket.error is now a child class of IOError.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>exception socket.herror</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>This exception is raised for address-related errors, i.e. for functions that use h_errno in the C API, including gethostbyname_ex() and gethostbyaddr().</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>The accompanying value is a pair (h_errno, string) representing an error returned by a library call. string represents the description of h_errno, as returned by the hstrerror() C function.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>exception socket.gaierror</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>This exception is raised for address-related errors, for getaddrinfo() and getnameinfo(). The accompanying value is a pair (error, string) representing an error returned by a library call. string represents the description of error, as returned by the gai_strerror() C function. The error value will match one of the EAI_* constants defined in this module.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>exception socket.timeout</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>This exception is raised when a timeout occurs on a socket which has had timeouts enabled via a prior call to settimeout(). The accompanying value is a string whose value is currently always “timed out”.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>New in version 2.3.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.AF_UNIX</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.AF_INET</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.AF_INET6</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>These constants represent the address (and protocol) families, used for the first argument to socket(). If the AF_UNIX constant is not defined then this protocol is unsupported.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.SOCK_STREAM</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.SOCK_DGRAM</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.SOCK_RAW</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.SOCK_RDM</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.SOCK_SEQPACKET</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>These constants represent the socket types, used for the second argument to socket(). (Only SOCK_STREAM and SOCK_DGRAM appear to be generally useful.)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>SO_*</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.SOMAXCONN</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>MSG_*</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>SOL_*</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>IPPROTO_*</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>IPPORT_*</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>INADDR_*</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>IP_*</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>IPV6_*</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>EAI_*</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>AI_*</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>NI_*</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>TCP_*</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Many constants of these forms, documented in the Unix documentation on sockets and/or the IP protocol, are also defined in the socket module. They are generally used in arguments to the setsockopt() and getsockopt() methods of socket objects. In most cases, only those symbols that are defined in the Unix header files are defined; for a few symbols, default values are provided.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>SIO_*</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>RCVALL_*</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Constants for Windows’ WSAIoctl(). The constants are used as arguments to the ioctl() method of socket objects.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>New in version 2.6.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>TIPC_*</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>TIPC related constants, matching the ones exported by the C socket API. See the TIPC documentation for more information.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>New in version 2.6.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.has_ipv6</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>This constant contains a boolean value which indicates if IPv6 is supported on this platform.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>New in version 2.3.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.create_connection(address[, timeout[, source_address]])</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Connect to a TCP service listening on the Internet address (a 2-tuple (host, port)), and return the socket object. This is a higher-level function than socket.connect(): if host is a non-numeric hostname, it will try to resolve it for both AF_INET and AF_INET6, and then try to connect to all possible addresses in turn until a connection succeeds. This makes it easy to write clients that are compatible to both IPv4 and IPv6.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Passing the optional timeout parameter will set the timeout on the socket instance before attempting to connect. If no timeout is supplied, the global default timeout setting returned by getdefaulttimeout() is used.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>If supplied, source_address must be a 2-tuple (host, port) for the socket to bind to as its source address before connecting. If host or port are ‘’ or 0 respectively the OS default behavior will be used.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>New in version 2.6.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Changed in version 2.7: source_address was added.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.getaddrinfo(host, port[, family[, socktype[, proto[, flags]]]])</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Translate the host/port argument into a sequence of 5-tuples that contain all the necessary arguments for creating a socket connected to that service. host is a domain name, a string representation of an IPv4/v6 address or None. port is a string service name such as &apos;http&apos;, a numeric port number or None. By passing None as the value of host and port, you can pass NULL to the underlying C API.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>The family, socktype and proto arguments can be optionally specified in order to narrow the list of addresses returned. By default, their value is 0, meaning that the full range of results is selected. The flags argument can be one or several of the AI_* constants, and will influence how results are computed and returned. Its default value is 0. For example, AI_NUMERICHOST will disable domain name resolution and will raise an error if host is a domain name.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>The function returns a list of 5-tuples with the following structure:</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>(family, socktype, proto, canonname, sockaddr)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>In these tuples, family, socktype, proto are all integers and are meant to be passed to the socket() function. canonname will be a string representing the canonical name of the host if AI_CANONNAME is part of the flags argument; else canonname will be empty. sockaddr is a tuple describing a socket address, whose format depends on the returned family (a (address, port) 2-tuple for AF_INET, a (address, port, flow info, scope id) 4-tuple for AF_INET6), and is meant to be passed to the socket.connect() method.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>The following example fetches address information for a hypothetical TCP connection to example.org on port 80 (results may differ on your system if IPv6 isn’t enabled):</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>&gt;&gt;&gt;</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>&gt;&gt;&gt; socket.getaddrinfo(&quot;example.org&quot;, 80, 0, 0, socket.IPPROTO_TCP)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>[(10, 1, 6, &apos;&apos;, (&apos;2606:2800:220:1:248:1893:25c8:1946&apos;, 80, 0, 0)),</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t xml:space="preserve"> </w:t></w:r><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>(2, 1, 6, &apos;&apos;, (&apos;93.184.216.34&apos;, 80))]</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>New in version 2.2.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.getfqdn([name])</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Return a fully qualified domain name for name. If name is omitted or empty, it is interpreted as the local host. To find the fully qualified name, the hostname returned by gethostbyaddr() is checked, followed by aliases for the host, if available. The first name which includes a period is selected. In case no fully qualified domain name is available, the hostname as returned by gethostname() is returned.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>New in version 2.0.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.gethostbyname(hostname)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Translate a host name to IPv4 address format. The IPv4 address is returned as a string, such as &apos;100.50.200.5&apos;. If the host name is an IPv4 address itself it is returned unchanged. See gethostbyname_ex() for a more complete interface. gethostbyname() does not support IPv6 name resolution, and getaddrinfo() should be used instead for IPv4/v6 dual stack support.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.gethostbyname_ex(hostname)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Translate a host name to IPv4 address format, extended interface. Return a triple (hostname, aliaslist, ipaddrlist) where hostname is the primary host name responding to the given ip_address, aliaslist is a (possibly empty) list of alternative host names for the same address, and ipaddrlist is a list of IPv4 addresses for the same interface on the same host (often but not always a single address). gethostbyname_ex() does not support IPv6 name resolution, and getaddrinfo() should be used instead for IPv4/v6 dual stack support.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.gethostname()</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Return a string containing the hostname of the machine where the Python interpreter is currently executing.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>If you want to know the current machine’s IP address, you may want to use gethostbyname(gethostname()). This operation assumes that there is a valid address-to-host mapping for the host, and the assumption does not always hold.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Note: gethostname() doesn’t always return the fully qualified domain name; use getfqdn() (see above).</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.gethostbyaddr(ip_address)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Return a triple (hostname, aliaslist, ipaddrlist) where hostname is the primary host name responding to the given ip_address, aliaslist is a (possibly empty) list of alternative host names for the same address, and ipaddrlist is a list of IPv4/v6 addresses for the same interface on the same host (most likely containing only a single address). To find the fully qualified domain name, use the function getfqdn(). gethostbyaddr() supports both IPv4 and IPv6.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.getnameinfo(sockaddr, flags)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Translate a socket address sockaddr into a 2-tuple (host, port). Depending on the settings of flags, the result can contain a fully-qualified domain name or numeric address representation in host. Similarly, port can contain a string port name or a numeric port number.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>New in version 2.2.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.getprotobyname(protocolname)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Translate an Internet protocol name (for example, &apos;icmp&apos;) to a constant suitable for passing as the (optional) third argument to the socket() function. This is usually only needed for sockets opened in “raw” mode (SOCK_RAW); for the normal socket modes, the correct protocol is chosen automatically if the protocol is omitted or zero.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.getservbyname(servicename[, protocolname])</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Translate an Internet service name and protocol name to a port number for that service. The optional protocol name, if given, should be &apos;tcp&apos; or &apos;udp&apos;, otherwise any protocol will match.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.getservbyport(port[, protocolname])</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Translate an Internet port number and protocol name to a service name for that service. The optional protocol name, if given, should be &apos;tcp&apos; or &apos;udp&apos;, otherwise any protocol will match.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.socket([family[, type[, proto]]])</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Create a new socket using the given address family, socket type and protocol number. The address family should be AF_INET (the default), AF_INET6 or AF_UNIX. The socket type should be SOCK_STREAM (the default), SOCK_DGRAM or perhaps one of the other SOCK_ constants. The protocol number is usually zero and may be omitted in that case.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.socketpair([family[, type[, proto]]])</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Build a pair of connected socket objects using the given address family, socket type, and protocol number. Address family, socket type, and protocol number are as for the socket() function above. The default family is AF_UNIX if defined on the platform; otherwise, the default is AF_INET. Availability: Unix.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>New in version 2.4.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.fromfd(fd, family, type[, proto])</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Duplicate the file descriptor fd (an integer as returned by a file object’s fileno() method) and build a socket object from the result. Address family, socket type and protocol number are as for the socket() function above. The file descriptor should refer to a socket, but this is not checked — subsequent operations on the object may fail if the file descriptor is invalid. This function is rarely needed, but can be used to get or set socket options on a socket passed to a program as standard input or output (such as a server started by the Unix inet daemon). The socket is assumed to be in blocking mode. Availability: Unix.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.ntohl(x)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Convert 32-bit positive integers from network to host byte order. On machines where the host byte order is the same as network byte order, this is a no-op; otherwise, it performs a 4-byte swap operation.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.ntohs(x)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Convert 16-bit positive integers from network to host byte order. On machines where the host byte order is the same as network byte order, this is a no-op; otherwise, it performs a 2-byte swap operation.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.htonl(x)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Convert 32-bit positive integers from host to network byte order. On machines where the host byte order is the same as network byte order, this is a no-op; otherwise, it performs a 4-byte swap operation.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.htons(x)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Convert 16-bit positive integers from host to network byte order. On machines where the host byte order is the same as network byte order, this is a no-op; otherwise, it performs a 2-byte swap operation.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.inet_aton(ip_string)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Convert an IPv4 address from dotted-quad string format (for example, ‘123.45.67.89’) to 32-bit packed binary format, as a string four characters in length. This is useful when conversing with a program that uses the standard C library and needs objects of type struct in_addr, which is the C type for the 32-bit packed binary this function returns.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>inet_aton() also accepts strings with less than three dots; see the Unix manual page inet(3) for details.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>If the IPv4 address string passed to this function is invalid, socket.error will be raised. Note that exactly what is valid depends on the underlying C implementation of inet_aton().</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>inet_aton() does not support IPv6, and inet_pton() should be used instead for IPv4/v6 dual stack support.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.inet_ntoa(packed_ip)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Convert a 32-bit packed IPv4 address (a string four characters in length) to its standard dotted-quad string representation (for example, ‘123.45.67.89’). This is useful when conversing with a program that uses the standard C library and needs objects of type struct in_addr, which is the C type for the 32-bit packed binary data this function takes as an argument.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>If the string passed to this function is not exactly 4 bytes in length, socket.error will be raised. inet_ntoa() does not support IPv6, and inet_ntop() should be used instead for IPv4/v6 dual stack support.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.inet_pton(address_family, ip_string)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Convert an IP address from its family-specific string format to a packed, binary format. inet_pton() is useful when a library or network protocol calls for an object of type struct in_addr (similar to inet_aton()) or struct in6_addr.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Supported values for address_family are currently AF_INET and AF_INET6. If the IP address string ip_string is invalid, socket.error will be raised. Note that exactly what is valid depends on both the value of address_family and the underlying implementation of inet_pton().</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Availability: Unix (maybe not all platforms).</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>New in version 2.3.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.inet_ntop(address_family, packed_ip)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Convert a packed IP address (a string of some number of characters) to its standard, family-specific string representation (for example, &apos;7.10.0.5&apos; or &apos;5aef:2b::8&apos;) inet_ntop() is useful when a library or network protocol returns an object of type struct in_addr (similar to inet_ntoa()) or struct in6_addr.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Supported values for address_family are currently AF_INET and AF_INET6. If the string packed_ip is not the correct length for the specified address family, ValueError will be raised. A socket.error is raised for errors from the call to inet_ntop().</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Availability: Unix (maybe not all platforms).</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>New in version 2.3.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.getdefaulttimeout()</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Return the default timeout in seconds (float) for new socket objects. A value of None indicates that new socket objects have no timeout. When the socket module is first imported, the default is None.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>New in version 2.3.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.setdefaulttimeout(timeout)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Set the default timeout in seconds (float) for new socket objects. A value of None indicates that new socket objects have no timeout. When the socket module is first imported, the default is None.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>New in version 2.3.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.SocketType</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>This is a Python type object that represents the socket object type. It is the same as type(socket(...)).</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>See also</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Module SocketServer</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Classes that simplify writing network servers.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Module ssl</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>A TLS/SSL wrapper for socket objects.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>17.2.1. Socket Objects</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Socket objects have the following methods. Except for makefile() these correspond to Unix system calls applicable to sockets.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.accept()</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Accept a connection. The socket must be bound to an address and listening for connections. The return value is a pair (conn, address) where conn is a new socket object usable to send and receive data on the connection, and address is the address bound to the socket on the other end of the connection.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.bind(address)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Bind the socket to address. The socket must not already be bound. (The format of address depends on the address family — see above.)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Note This method has historically accepted a pair of parameters for AF_INET addresses instead of only a tuple. This was never intentional and is no longer available in Python 2.0 and later.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.close()</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Close the socket. All future operations on the socket object will fail. The remote end will receive no more data (after queued data is flushed). Sockets are automatically closed when they are garbage-collected.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Note close() releases the resource associated with a connection but does not necessarily close the connection immediately. If you want to close the connection in a timely fashion, call shutdown() before close().</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.connect(address)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Connect to a remote socket at address. (The format of address depends on the address family — see above.)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Note This method has historically accepted a pair of parameters for AF_INET addresses instead of only a tuple. This was never intentional and is no longer available in Python 2.0 and later.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.connect_ex(address)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Like connect(address), but return an error indicator instead of raising an exception for errors returned by the C-level connect() call (other problems, such as “host not found,” can still raise exceptions). The error indicator is 0 if the operation succeeded, otherwise the value of the errno variable. This is useful to support, for example, asynchronous connects.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Note This method has historically accepted a pair of parameters for AF_INET addresses instead of only a tuple. This was never intentional and is no longer available in Python 2.0 and later.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.fileno()</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Return the socket’s file descriptor (a small integer). This is useful with select.select().</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Under Windows the small integer returned by this method cannot be used where a file descriptor can be used (such as os.fdopen()). Unix does not have this limitation.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.getpeername()</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Return the remote address to which the socket is connected. This is useful to find out the port number of a remote IPv4/v6 socket, for instance. (The format of the address returned depends on the address family — see above.) On some systems this function is not supported.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.getsockname()</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Return the socket’s own address. This is useful to find out the port number of an IPv4/v6 socket, for instance. (The format of the address returned depends on the address family — see above.)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.getsockopt(level, optname[, buflen])</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Return the value of the given socket option (see the Unix man page getsockopt(2)). The needed symbolic constants (SO_* etc.) are defined in this module. If buflen is absent, an integer option is assumed and its integer value is returned by the function. If buflen is present, it specifies the maximum length of the buffer used to receive the option in, and this buffer is returned as a string. It is up to the caller to decode the contents of the buffer (see the optional built-in module struct for a way to decode C structures encoded as strings).</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.ioctl(control, option)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Platform:</w:t><w:tab/><w:t>Windows</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>The ioctl() method is a limited interface to the WSAIoctl system interface. Please refer to the Win32 documentation for more information.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>On other platforms, the generic fcntl.fcntl() and fcntl.ioctl() functions may be used; they accept a socket object as their first argument.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>New in version 2.6.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.listen(backlog)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Listen for connections made to the socket. The backlog argument specifies the maximum number of queued connections and should be at least 0; the maximum value is system-dependent (usually 5), the minimum value is forced to 0.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.makefile([mode[, bufsize]])</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Return a file object associated with the socket. (File objects are described in File Objects.) The file object does not close the socket explicitly when its close() method is called, but only removes its reference to the socket object, so that the socket will be closed if it is not referenced from anywhere else.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>The socket must be in blocking mode (it can not have a timeout). The optional mode and bufsize arguments are interpreted the same way as by the built-in file() function.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Note On Windows, the file-like object created by makefile() cannot be used where a file object with a file descriptor is expected, such as the stream arguments of subprocess.Popen().</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.recv(bufsize[, flags])</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Receive data from the socket. The return value is a string representing the data received. The maximum amount of data to be received at once is specified by bufsize. See the Unix manual page recv(2) for the meaning of the optional argument flags; it defaults to zero.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Note For best match with hardware and network realities, the value of bufsize should be a relatively small power of 2, for example, 4096.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.recvfrom(bufsize[, flags])</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Receive data from the socket. The return value is a pair (string, address) where string is a string representing the data received and address is the address of the socket sending the data. See the Unix manual page recv(2) for the meaning of the optional argument flags; it defaults to zero. (The format of address depends on the address family — see above.)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.recvfrom_into(buffer[, nbytes[, flags]])</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Receive data from the socket, writing it into buffer instead of creating a new string. The return value is a pair (nbytes, address) where nbytes is the number of bytes received and address is the address of the socket sending the data. See the Unix manual page recv(2) for the meaning of the optional argument flags; it defaults to zero. (The format of address depends on the address family — see above.)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>New in version 2.5.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.recv_into(buffer[, nbytes[, flags]])</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Receive up to nbytes bytes from the socket, storing the data into a buffer rather than creating a new string. If nbytes is not specified (or 0), receive up to the size available in the given buffer. Returns the number of bytes received. See the Unix manual page recv(2) for the meaning of the optional argument flags; it defaults to zero.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>New in version 2.5.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.send(string[, flags])</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Send data to the socket. The socket must be connected to a remote socket. The optional flags argument has the same meaning as for recv() above. Returns the number of bytes sent. Applications are responsible for checking that all data has been sent; if only some of the data was transmitted, the application needs to attempt delivery of the remaining data. For further information on this concept, consult the Socket Programming HOWTO.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.sendall(string[, flags])</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Send data to the socket. The socket must be connected to a remote socket. The optional flags argument has the same meaning as for recv() above. Unlike send(), this method continues to send data from string until either all data has been sent or an error occurs. None is returned on success. On error, an exception is raised, and there is no way to determine how much data, if any, was successfully sent.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.sendto(string, address)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.sendto(string, flags, address)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Send data to the socket. The socket should not be connected to a remote socket, since the destination socket is specified by address. The optional flags argument has the same meaning as for recv() above. Return the number of bytes sent. (The format of address depends on the address family — see above.)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.setblocking(flag)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Set blocking or non-blocking mode of the socket: if flag is 0, the socket is set to non-blocking, else to blocking mode. Initially all sockets are in blocking mode. In non-blocking mode, if a recv() call doesn’t find any data, or if a send() call can’t immediately dispose of the data, an error exception is raised; in blocking mode, the calls block until they can proceed. s.setblocking(0) is equivalent to s.settimeout(0.0); s.setblocking(1) is equivalent to s.settimeout(None).</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.settimeout(value)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Set a timeout on blocking socket operations. The value argument can be a nonnegative float expressing seconds, or None. If a float is given, subsequent socket operations will raise a timeout exception if the timeout period value has elapsed before the operation has completed. Setting a timeout of None disables timeouts on socket operations. s.settimeout(0.0) is equivalent to s.setblocking(0); s.settimeout(None) is equivalent to s.setblocking(1).</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>New in version 2.3.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.gettimeout()</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Return the timeout in seconds (float) associated with socket operations, or None if no timeout is set. This reflects the last call to setblocking() or settimeout().</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>New in version 2.3.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Some notes on socket blocking and timeouts: A socket object can be in one of three modes: blocking, non-blocking, or timeout. Sockets are always created in blocking mode. In blocking mode, operations block until complete or the system returns an error (such as connection timed out). In non-blocking mode, operations fail (with an error that is unfortunately system-dependent) if they cannot be completed immediately. In timeout mode, operations fail if they cannot be completed within the timeout specified for the socket or if the system returns an error. The setblocking() method is simply a shorthand for certain settimeout() calls.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Timeout mode internally sets the socket in non-blocking mode. The blocking and timeout modes are shared between file descriptors and socket objects that refer to the same network endpoint. A consequence of this is that file objects returned by the makefile() method must only be used when the socket is in blocking mode; in timeout or non-blocking mode file operations that cannot be completed immediately will fail.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Note that the connect() operation is subject to the timeout setting, and in general it is recommended to call settimeout() before calling connect() or pass a timeout parameter to create_connection(). The system network stack may return a connection timeout error of its own regardless of any Python socket timeout setting.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.setsockopt(level, optname, value)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Set the value of the given socket option (see the Unix manual page setsockopt(2)). The needed symbolic constants are defined in the socket module (SO_* etc.). The value can be an integer or a string representing a buffer. In the latter case it is up to the caller to ensure that the string contains the proper bits (see the optional built-in module struct for a way to encode C structures as strings).</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.shutdown(how)</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Shut down one or both halves of the connection. If how is SHUT_RD, further receives are disallowed. If how is SHUT_WR, further sends are disallowed. If how is SHUT_RDWR, further sends and receives are disallowed. Depending on the platform, shutting down one half of the connection can also close the opposite half (e.g. on Mac OS X, shutdown(SHUT_WR) does not allow further reads on the other end of the connection).</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Note that there are no methods read() or write(); use recv() and send() without flags argument instead.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Socket objects also have these (read-only) attributes that correspond to the values given to the socket constructor.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.family</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>The socket family.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>New in version 2.5.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.type</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>The socket type.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>New in version 2.5.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>socket.proto</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>The socket protocol.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>New in version 2.5.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>17.2.2. Example</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="PreformattedText"/><w:rPr><w:b w:val="false"/><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr></w:pPr><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t xml:space="preserve">Here are four minimal example programs using the TCP/IP protocol: a server that echoes all data that it receives back (servicing only one client), and a client </w:t></w:r><w:r><w:rPr><w:b w:val="false"/><w:bCs w:val="false"/></w:rPr><w:t>Hello World</w:t></w:r></w:p><w:sectPr><w:type w:val="nextPage"/><w:pgSz w:w="12240" w:h="15840"/><w:pgMar w:left="1134" w:right="1134" w:header="0" w:top="1134" w:footer="0" w:bottom="1134" w:gutter="0"/><w:pgNumType w:fmt="decimal"/><w:formProt w:val="false"/><w:textDirection w:val="lrTb"/><w:docGrid w:type="default" w:linePitch="240" w:charSpace="4294961151"/></w:sectPr></w:body></w:document>